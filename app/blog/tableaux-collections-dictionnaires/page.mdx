export const meta = {
  title: "Tableaux, Collections et Dictionnaires VBA - le trio qu'il faut enfin comprendre",
  description:
    'Comprendre enfin les diffÃ©rences entre Tableaux, Collections et Dictionnaires en VBA â€” quand utiliser chacun, leurs avantages et exemples concrets.',
  date: '2025-10-20',
  author: 'DELGERY SÃ©bastien',
}

import { PostHeader } from '@/components/PostHeader'

<PostHeader {...meta} />

Quand on code en VBA, on finit toujours par croiser ces trois structures : **le tableau**, **la collection** et **le dictionnaire**.  
Elles paraissent interchangeablesâ€¦ jusquâ€™Ã  ce quâ€™on sâ€™y perde entre indices, clÃ©s et typages.  
Voici un rappel clair pour choisir la bonne, au bon moment.

---

## ðŸ§© 1. Le tableau â€” rapide, mais rigide

Le **tableau** est la base : un espace mÃ©moire fixe (ou redimensionnable) indexÃ© par nombre.

```vba
Dim arr() As Variant
ReDim arr(1 To 3)
arr(1) = "Excel"
arr(2) = "VBA"
arr(3) = "SQL"

Debug.Print arr(2)    ' â†’ VBA
```

âœ… **Avantages :**

- trÃ¨s rapide (stockÃ© en mÃ©moire contiguÃ«)
- parfait pour parcourir des lignes/colonnes
- compatible avec les `Range.Value`

âš ï¸ **Limites :**

- index numÃ©rique uniquement (pas de clÃ© texte)
- redimensionnement coÃ»teux
- pas de suppression dâ€™Ã©lÃ©ment â€œau milieuâ€

ðŸ’¡ Astuce : pour traiter un tableau Excel entier dâ€™un coup, câ€™est imbattable :

```vba
arr = Range("A1:C1000").Value
```

---

## ðŸ“¦ 2. La collection â€” souple, simple, sans clÃ© explicite

Une **Collection** est un conteneur dynamique natif VBA, parfait pour empiler des objets ou valeurs sans se soucier des tailles.

```vba
Dim oCol As New Collection
oCol.Add "Excel"
oCol.Add "VBA"
oCol.Add "SQL"

Debug.Print oCol(2)          ' â†’ VBA
Debug.Print oCol.Count       ' â†’ 3
```

âœ… **Avantages :**

- ajout/suppression ultra simple (`.Add`, `.Remove`)
- accepte nâ€™importe quel type (objets, chaÃ®nes, tableauxâ€¦)
- possible de donner une clÃ© texte (facultative)

âš ï¸ **Limites :**

- pas de vÃ©rification dâ€™existence (`On Error Resume Next` obligatoire)
- plus lent quâ€™un tableau sur gros volumes
- pas dâ€™accÃ¨s direct aux clÃ©s (`For Each` uniquement)

ðŸ’¡ Exemple avec clÃ© facultative :

```vba
oCol.Add "SÃ©bastien", "Auteur"
Debug.Print oCol("Auteur")
```

---

## ðŸ§  3. Le dictionnaire â€” rapide, structurÃ©, clÃ© â†’ valeur

Le **Scripting.Dictionary** (librairie _Microsoft Scripting Runtime_) est lâ€™Ã©quivalent VBA dâ€™un `Map` : on associe **une clÃ© unique** Ã  **une valeur**.

```vba
Dim oDic As Object
Set oDic = CreateObject("Scripting.Dictionary")

oDic("Langage") = "VBA"
oDic("AnnÃ©e") = 1995
oDic("Auteur") = "Microsoft"

Debug.Print oDic("Auteur")     ' â†’ Microsoft
```

âœ… **Avantages :**

- accÃ¨s direct par clÃ© (texte, numÃ©riqueâ€¦)
- `.Exists` pour tester avant dâ€™ajouter
- trÃ¨s rapide en lookup (table de hachage)
- `.Keys` et `.Items` pour parcourir

âš ï¸ **Limites :**

- nÃ©cessite `CreateObject` (non natif VBA)
- pas triÃ©
- pas de doublons de clÃ©

ðŸ’¡ Exemples utiles :

```vba
If Not oDic.Exists("Langage") Then oDic("Langage") = "VBA"
For Each k In oDic.Keys
    Debug.Print k, oDic(k)
Next
```

---

## âš™ï¸ 4. Tableau vs Collection vs Dictionnaire â€” le comparatif

| CaractÃ©ristique  | **Tableau**            | **Collection**                | **Dictionary**          |
| ---------------- | ---------------------- | ----------------------------- | ----------------------- |
| Type dâ€™index     | NumÃ©rique              | NumÃ©rique / Texte (optionnel) | Texte / NumÃ©rique       |
| Taille dynamique | Redim                  | Oui                           | Oui                     |
| AccÃ¨s direct     | `arr(i)`               | `col(i)` / `col("clÃ©")`       | `d("clÃ©")`              |
| Test dâ€™existence | Non                    | Non (sauf erreur)             | `.Exists("clÃ©")`        |
| ItÃ©ration        | `For i=LBound..UBound` | `For Each`                    | `For Each`              |
| Performance      | â­â­â­                 | â­â­                          | â­â­â­                  |
| Multi-dimension  | Oui                    | Non                           | Non                     |
| Parfait pour     | DonnÃ©es tabulaires     | Listes souples / objets       | Lookup, mapping, caches |

---

## ðŸ§© 5. Combo gagnant : les hybrides

On peut (et souvent on doit) **combiner** les structures :

### Dictionnaire de tableaux

```vba
oDic("Ligne1") = Array("A", "B", "C")
Debug.Print oDic("Ligne1")(2)    ' â†’ B
```

### Collection de dictionnaires

```vba
Dim oCol As New Collection, oDic2 As Object
Set oDic2 = CreateObject("Scripting.Dictionary")
oDic2("Nom") = "Delgery"
oDic2("Role") = "Consultant"
oCol.Add oDic2, "Profil"

Debug.Print oCol("Profil")("Nom")
```

---

## ðŸª„ En rÃ©sumÃ©

> ðŸ”¹ **Tableau** â†’ performance brute  
> ðŸ”¹ **Collection** â†’ souplesse sans prise de tÃªte  
> ðŸ”¹ **Dictionnaire** â†’ structure clÃ©/valeur, parfaite pour anonymisation, mapping, caches, agrÃ©gations

Et comme toujours en VBA : commence simple, optimise plus tard.  
Le bon conteneur est celui qui **Ã©claire ton code, pas celui qui impressionne ton compilateur** ðŸ˜‰

---

_Article rÃ©digÃ© par **DELGERY SÃ©bastien** â€“ Consultant PPM & BI / DÃ©veloppeur VBA & .NET_  
_Â© Overview Software Â· Automatisation, fiabilitÃ©, clartÃ©._
